diff -U 3 -Nar o/ieee80211/ieee80211_crypt_tkip.c n/ieee80211/ieee80211_crypt_tkip.c
--- o/ieee80211/ieee80211_crypt_tkip.c	2008-02-16 13:47:42.000000000 +0300
+++ n/ieee80211/ieee80211_crypt_tkip.c	2008-02-16 14:12:34.000000000 +0300
@@ -412,9 +412,13 @@
 	icv[3] = crc >> 24;
 
 	crypto_blkcipher_setkey(tkey->tx_tfm_arc4, rc4key, 16);
+#if(LINUX_VERSION_CODE < KERNEL_VERSION(2,6,24))	
 	sg.page = virt_to_page(pos);
 	sg.offset = offset_in_page(pos);
 	sg.length = len + 4;
+#else
+	sg_init_one(&sg, pos, len + 4);
+#endif
 #if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,18)
 	return crypto_blkcipher_encrypt(&desc, &sg, &sg, len + 4);
 #else
@@ -512,9 +516,13 @@
 	plen = skb->len - hdr_len - 12;
 
 	crypto_blkcipher_setkey(tkey->rx_tfm_arc4, rc4key, 16);
+#if(LINUX_VERSION_CODE < KERNEL_VERSION(2,6,24))	
 	sg.page = virt_to_page(pos);
 	sg.offset = offset_in_page(pos);
 	sg.length = plen + 4;
+#else
+	sg_init_one(&sg, pos, plen + 4);
+#endif
 #if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,18)
 	if (crypto_blkcipher_decrypt(&desc, &sg, &sg, plen + 4)) {
 #else
@@ -572,6 +580,7 @@
 		printk(KERN_WARNING "michael_mic: tfm_michael == NULL\n");
 		return -1;
 	}
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,24)	
 	sg[0].page = virt_to_page(hdr);
 	sg[0].offset = offset_in_page(hdr);
 	sg[0].length = 16;
@@ -579,6 +588,11 @@
 	sg[1].page = virt_to_page(data);
 	sg[1].offset = offset_in_page(data);
 	sg[1].length = data_len;
+#else
+	sg_init_table(sg, 2);
+	sg_set_buf(&sg[0], hdr, 16);
+	sg_set_buf(&sg[1], data, data_len);
+#endif
 
 #if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,18)
 	if (crypto_hash_setkey(tfm_michael, key, 8))
diff -U 3 -Nar o/ieee80211/ieee80211_crypt_wep.c n/ieee80211/ieee80211_crypt_wep.c
--- o/ieee80211/ieee80211_crypt_wep.c	2008-02-16 13:47:42.000000000 +0300
+++ n/ieee80211/ieee80211_crypt_wep.c	2008-02-16 14:16:59.000000000 +0300
@@ -187,9 +187,13 @@
 	icv[3] = crc >> 24;
 
 	crypto_blkcipher_setkey(wep->tx_tfm, key, klen);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,24)	
 	sg.page = virt_to_page(pos);
 	sg.offset = offset_in_page(pos);
 	sg.length = len + 4;
+#else
+	sg_init_one(&sg, pos, len + 4);
+#endif
 #if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,18)
 	return crypto_blkcipher_encrypt(&desc, &sg, &sg, len + 4);
 #else
@@ -235,9 +239,13 @@
 	plen = skb->len - hdr_len - 8;
 
 	crypto_blkcipher_setkey(wep->rx_tfm, key, klen);
+#if(LINUX_VERSION_CODE < KERNEL_VERSION(2,6,24))	
 	sg.page = virt_to_page(pos);
 	sg.offset = offset_in_page(pos);
 	sg.length = plen + 4;
+#else
+	sg_init_one(&sg, pos, plen + 4);
+#endif
 #if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,18)
 	if (crypto_blkcipher_decrypt(&desc, &sg, &sg, plen + 4))
 #else
diff -U 3 -Nar o/rtl8187-dev/ieee80211_crypt_wep.c n/rtl8187-dev/ieee80211_crypt_wep.c
--- o/rtl8187-dev/ieee80211_crypt_wep.c	2008-02-16 13:47:45.000000000 +0300
+++ n/rtl8187-dev/ieee80211_crypt_wep.c	2008-02-16 21:24:09.000000000 +0300
@@ -64,7 +64,12 @@
 	u8 key[WEP_KEY_LEN + 1];
 	u8 key_len;
 	u8 key_idx;
+#if(LINUX_VERSION_CODE < KERNEL_VERSION(2,6,21))
 	struct crypto_tfm *tfm;
+#else
+	struct crypto_blkcipher *tx_tfm;
+	struct crypto_blkcipher *rx_tfm;
+#endif
 };
 
 
@@ -85,19 +90,38 @@
 	memset(priv, 0, sizeof(*priv));
 	priv->key_idx = keyidx;
 
+	
+#if(LINUX_VERSION_CODE < KERNEL_VERSION(2,6,21))
 	priv->tfm = crypto_alloc_tfm("arc4", 0);
 	if (priv->tfm == NULL) {
-		printk(KERN_DEBUG "ieee80211_crypt_wep: could not allocate "
-		       "crypto API arc4\n");
-		goto fail;
+	    printk(KERN_DEBUG "ieee80211_crypt_wep: could not allocate "
+		"crypto API arc4\n");
+	    goto fail;
 	}
-
+#else
+	priv->tx_tfm = crypto_alloc_blkcipher("ecb(arc4)", 0, CRYPTO_ALG_ASYNC);
+	if (IS_ERR(priv->tx_tfm)) {
+	    printk(KERN_DEBUG "ieee80211_crypt_wep: could not allocate "
+		"crypto API arc4\n");
+	    priv->tx_tfm = NULL;
+	    goto fail;
+	}
+	priv->rx_tfm = crypto_alloc_blkcipher("ecb(arc4)", 0, CRYPTO_ALG_ASYNC);
+	if (IS_ERR(priv->rx_tfm)) {
+	    printk(KERN_DEBUG "ieee80211_crypt_wep: could not allocate "
+		"crypto API arc4\n");
+	    priv->rx_tfm = NULL;
+	    goto fail;
+	}
+#endif
+							
 	/* start WEP IV from a random value */
 	get_random_bytes(&priv->iv, 4);
 
 	return priv;
 
 fail:
+	#if(LINUX_VERSION_CODE < KERNEL_VERSION(2,6,21))
 	if (priv) {
 		if (priv->tfm)
 			crypto_free_tfm(priv->tfm);
@@ -107,8 +131,17 @@
 	module_put(THIS_MODULE);
 #else
 	MOD_DEC_USE_COUNT;
-#endif
+#endif 
+	#else
+	if (priv) {
+	    if (priv->tx_tfm)
+		crypto_free_blkcipher(priv->tx_tfm);
+	    if (priv->rx_tfm)
+		crypto_free_blkcipher(priv->rx_tfm);
+	    kfree(priv);
+	}
 
+	#endif
 	return NULL;
 }
 
@@ -116,8 +149,18 @@
 static void prism2_wep_deinit(void *priv)
 {
 	struct prism2_wep_data *_priv = priv;
-	if (_priv && _priv->tfm)
-		crypto_free_tfm(_priv->tfm);
+#if(LINUX_VERSION_CODE < KERNEL_VERSION(2,6,21))
+    if (_priv && _priv->tfm)
+    crypto_free_tfm(_priv->tfm);
+#else
+    if (_priv) {
+	if (_priv->tx_tfm)
+	    crypto_free_blkcipher(_priv->tx_tfm);
+        if (_priv->rx_tfm)
+	    crypto_free_blkcipher(_priv->rx_tfm);
+    }
+#endif
+			
 	kfree(priv);
 #ifdef NEW_MODULE_CODE
 	module_put(THIS_MODULE);
@@ -136,6 +179,10 @@
 static int prism2_wep_encrypt(struct sk_buff *skb, int hdr_len, void *priv)
 {
 	struct prism2_wep_data *wep = priv;
+#if(LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,21))
+	struct blkcipher_desc desc = {.tfm = wep->tx_tfm};
+#endif
+
 	u32 crc, klen, len;
 	u8 key[WEP_KEY_LEN + 3];
 	u8 *pos, *icv;
@@ -180,13 +227,24 @@
 	icv[2] = crc >> 16;
 	icv[3] = crc >> 24;
 
+	#if(LINUX_VERSION_CODE < KERNEL_VERSION(2,6,21))
 	crypto_cipher_setkey(wep->tfm, key, klen);
 	sg.page = virt_to_page(pos);
 	sg.offset = offset_in_page(pos);
 	sg.length = len + 4;
 	crypto_cipher_encrypt(wep->tfm, &sg, &sg, len + 4);
-
 	return 0;
+	#else
+	crypto_blkcipher_setkey(wep->tx_tfm, key, klen);
+#if(LINUX_VERSION_CODE < KERNEL_VERSION(2,6,24))
+	sg.page = virt_to_page(pos);
+	sg.offset = offset_in_page(pos);
+	sg.length = len + 4;
+#else
+	sg_init_one(&sg, pos, len + 4);
+#endif
+	return crypto_blkcipher_encrypt(&desc, &sg, &sg, len + 4);
+	#endif
 }
 
 
@@ -200,6 +258,9 @@
 static int prism2_wep_decrypt(struct sk_buff *skb, int hdr_len, void *priv)
 {
 	struct prism2_wep_data *wep = priv;
+#if(LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,21))
+	struct blkcipher_desc desc = {.tfm = wep->rx_tfm};
+#endif
 	u32 crc, klen, plen;
 	u8 key[WEP_KEY_LEN + 3];
 	u8 keyidx, *pos, icv[4];
@@ -224,11 +285,24 @@
 	/* Apply RC4 to data and compute CRC32 over decrypted data */
 	plen = skb->len - hdr_len - 8;
 
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,21))
 	crypto_cipher_setkey(wep->tfm, key, klen);
 	sg.page = virt_to_page(pos);
 	sg.offset = offset_in_page(pos);
 	sg.length = plen + 4;
 	crypto_cipher_decrypt(wep->tfm, &sg, &sg, plen + 4);
+#else
+	crypto_blkcipher_setkey(wep->rx_tfm, key, klen);
+#if(LINUX_VERSION_CODE < KERNEL_VERSION(2,6,24))
+	sg.page = virt_to_page(pos);
+	sg.offset = offset_in_page(pos);
+	sg.length = plen + 4;
+#else
+	sg_init_one(&sg, pos, plen + 4);
+#endif
+	if (crypto_blkcipher_decrypt(&desc, &sg, &sg, plen + 4))
+		return -7;
+#endif
 
 	crc = ~crc32_le(~0, pos, plen);
 	icv[0] = crc;
diff -U 3 -Nar o/rtl8187-dev/ieee80211_module.c n/rtl8187-dev/ieee80211_module.c
--- o/rtl8187-dev/ieee80211_module.c	2008-02-16 13:47:45.000000000 +0300
+++ n/rtl8187-dev/ieee80211_module.c	2008-02-16 18:50:10.000000000 +0300
@@ -670,8 +670,14 @@
 	ieee->associate_timer.function = ieee80211_associate_abort_;
 /*	init_waitqueue_head(&ieee->assoc_queue);
 	ieee->workqueue = create_workqueue(DRV_NAME);*/
+/* Below is had to be discussed !!! */	
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,20))	
 	INIT_WORK(&ieee->associate_wq,(void(*)(void*)) ieee80211_associate_step1,ieee);
 	INIT_WORK(&ieee->associate_complete_wq,(void(*)(void*)) ieee80211_associate_complete,ieee);
+#else
+	INIT_WORK(&ieee->associate_wq,(void(*)(void*)) ieee80211_associate_step1); 
+	INIT_WORK(&ieee->associate_complete_wq,(void(*)(void*)) ieee80211_associate_complete); 
+#endif
 	init_htables(ieee);
 	
 	return ieee;
diff -U 3 -Nar o/rtl8187-dev/ieee80211_rx.c n/rtl8187-dev/ieee80211_rx.c
--- o/rtl8187-dev/ieee80211_rx.c	2008-02-16 13:47:45.000000000 +0300
+++ n/rtl8187-dev/ieee80211_rx.c	2008-02-16 15:01:25.000000000 +0300
@@ -1153,8 +1153,13 @@
 	if (skb2 != NULL) {
 		/* send to wireless media */
 		skb2->protocol = __constant_htons(ETH_P_802_3);
+/* These needs to be discussed */
+#if(LINUX_VERSION_CODE < KERNEL_VERSION(2,6,22))		
 		skb2->mac.raw = skb2->nh.raw = skb2->data;
+#else
+		skb2->mac_header= skb2->network_header = skb2->data;
 		/* skb2->nh.raw = skb2->data + ETH_HLEN; */
+#endif
 		skb2->dev = dev;
 		dev_queue_xmit(skb2);
 	}
diff -U 3 -Nar o/rtl8187-dev/r8187_core.c n/rtl8187-dev/r8187_core.c
--- o/rtl8187-dev/r8187_core.c	2008-02-16 13:47:45.000000000 +0300
+++ n/rtl8187-dev/r8187_core.c	2008-02-16 21:42:41.000000000 +0300
@@ -89,24 +89,33 @@
 static int hwseqnum = 0;
 static int hwwep = 0;
 static int channels = 0x3fff;
-
+static int force_card = 0;
 
 MODULE_LICENSE("GPL");
 MODULE_DEVICE_TABLE(usb, rtl8187_usb_id_tbl);
 MODULE_AUTHOR("Andrea Merello <andreamrl@tiscali.it>");
 MODULE_DESCRIPTION("Linux driver for Realtek RTL8187 WiFi cards");
-
+#if  LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 9)
 MODULE_PARM(ifname,"s");
 MODULE_PARM_DESC(devname," Net interface name, wlan%d=default");
 
 MODULE_PARM(hwseqnum,"i");
 MODULE_PARM_DESC(hwseqnum," Try to use hardware 802.11 header sequence numbers. Zero=default");
+
 #if 0
 MODULE_PARM(hwwep,"i");
 MODULE_PARM_DESC(hwwep," Try to use hardware WEP support. Still broken and not available on all cards");
 #endif
 MODULE_PARM(channels,"i");
 MODULE_PARM_DESC(channels," Channel bitmask for specific locales. NYI");
+#else
+module_param(ifname, charp, S_IRUGO|S_IWUSR );
+/* Uncomment following if needed */
+/*module_param(hwseqnum,int, S_IRUGO|S_IWUSR);
+module_param(hwwep,int, S_IRUGO|S_IWUSR);*/
+module_param(channels,int, S_IRUGO|S_IWUSR);
+module_param(force_card, int, S_IRUGO|S_IWUSR);
+#endif
 
 
 static int __devinit rtl8187_usb_probe(struct usb_interface *intf,
@@ -115,7 +124,9 @@
 static void __devexit rtl8187_usb_disconnect(struct usb_interface *intf);
 
 static struct usb_driver rtl8187_usb_driver = {
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 15)    
 	.owner		= THIS_MODULE,
+#endif	
 	.name		= RTL8187_MODULE_NAME,	          /* Driver name   */
 	.id_table	= rtl8187_usb_id_tbl,	          /* PCI_ID table  */
 	.probe		= rtl8187_usb_probe,	          /* probe fn      */
@@ -479,13 +490,21 @@
 void rtl8180_proc_module_init(void)
 {	
 	DMESG("Initializing proc filesystem");
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 24)	
 	rtl8180_proc=create_proc_entry(RTL8187_MODULE_NAME, S_IFDIR, proc_net);
+#else
+	rtl8180_proc=create_proc_entry(RTL8187_MODULE_NAME, S_IFDIR, init_net.proc_net);
+#endif
 }
 
 
 void rtl8180_proc_module_remove(void)
 {
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 24)
 	remove_proc_entry(RTL8187_MODULE_NAME, proc_net);
+#else
+        remove_proc_entry(RTL8187_MODULE_NAME, init_net.proc_net);
+#endif
 }
 
 
@@ -2978,9 +2997,13 @@
 #endif
 #endif
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 20)
 	INIT_WORK(&priv->IBSS_work,(void(*)(void*)) rtl8180_IBSS_create_wq,dev);
 	INIT_WORK(&priv->scan_work,(void(*)(void*)) rtl8180_scan_wq,dev);
-	
+#else
+	INIT_WORK(&priv->IBSS_work,(void(*)(void*)) rtl8180_IBSS_create_wq);
+	INIT_WORK(&priv->scan_work,(void(*)(void*)) rtl8180_scan_wq);
+#endif
 	tasklet_init(&priv->irq_rx_tasklet,
 		     (void(*)(unsigned long)) rtl8180_irq_rx_tasklet,
 		     (unsigned long)priv);
@@ -3973,8 +3996,10 @@
 	struct usb_device *udev = interface_to_usbdev(intf);
 	
 	dev = alloc_etherdev(sizeof(*priv));
-	
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 24)
 	SET_MODULE_OWNER(dev);
+#endif
 	usb_set_intfdata(intf, dev);	
 	//pci_set_drvdata(pdev, dev);
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 0)	
diff -U 3 -Nar o/rtl8187-newstack/r8187_core.c n/rtl8187-newstack/r8187_core.c
--- o/rtl8187-newstack/r8187_core.c	2008-02-16 13:47:47.000000000 +0300
+++ n/rtl8187-newstack/r8187_core.c	2008-02-16 23:37:53.000000000 +0300
@@ -407,13 +407,21 @@
 void rtl8180_proc_module_init(void)
 {	
 	DMESG("Initializing proc filesystem");
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,24))
 	rtl8180_proc=create_proc_entry(RTL8187_MODULE_NAME, S_IFDIR, proc_net);
+#else
+	rtl8180_proc=create_proc_entry(RTL8187_MODULE_NAME, S_IFDIR, init_net.proc_net);
+#endif
 }
 
 
 void rtl8180_proc_module_remove(void)
 {
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,24)) 
 	remove_proc_entry(RTL8187_MODULE_NAME, proc_net);
+#else
+	remove_proc_entry(RTL8187_MODULE_NAME, init_net.proc_net);
+#endif
 }
 
 
@@ -2407,7 +2415,9 @@
 	
 	dev = alloc_ieee80211(sizeof(struct r8180_priv));
 	
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,24))
 	SET_MODULE_OWNER(dev);
+#endif	
 	usb_set_intfdata(intf, dev);	
 	
 	SET_NETDEV_DEV(dev, &intf->dev);
diff -U 3 -Nar o/rtl818x-newstack/r8180.h n/rtl818x-newstack/r8180.h
--- o/rtl818x-newstack/r8180.h	2008-02-16 13:47:49.000000000 +0300
+++ n/rtl818x-newstack/r8180.h	2008-02-17 01:09:28.000000000 +0300
@@ -46,13 +46,14 @@
 #include <linux/delay.h>
 #include <linux/rtnetlink.h>	//for rtnl_lock()
 #include <linux/wireless.h>
-#include <net/mac80211.h>
-#include <net/ieee80211softmac.h>
+//#include <net/mac80211.h>
+//#include <net/ieee80211softmac.h>
 #include <linux/timer.h>
 #include <linux/proc_fs.h>	// Necessary because we use the proc fs
 #include <linux/if_arp.h>
 #include <asm/io.h>
 #include <asm/semaphore.h>
+#include "ieee80211.h"
 
 #define EPROM_93c46 0
 #define EPROM_93c56 1
@@ -244,44 +245,7 @@
 	short ack_tx_to_ieee;
 }r8180_priv;
 
-enum ieee80211_state {
 
-        /* the card is not linked at all */
-        IEEE80211_NOLINK = 0,
-
-        /* IEEE80211_ASSOCIATING* are for BSS client mode
-         * the driver shall not perform RX filtering unless
-         * the state is LINKED.
-         * The driver shall just check for the state LINKED and
-         * defaults to NOLINK for ALL the other states (including
-         * LINKED_SCANNING)
-         */
-
-        /* the association procedure will start (wq scheduling)*/
-        IEEE80211_ASSOCIATING,
-        IEEE80211_ASSOCIATING_RETRY,
-
-        /* the association procedure is sending AUTH request*/
-        IEEE80211_ASSOCIATING_AUTHENTICATING,
-  
-        /* the association procedure has successfully authentcated
-         * and is sending association request
-         */
-        IEEE80211_ASSOCIATING_AUTHENTICATED,
-
-        /* the link is ok. the card associated to a BSS or linked
-         * to a ibss cell or acting as an AP and creating the bss
-         */
-        IEEE80211_LINKED,
-
-        /* same as LINKED, but the driver shall apply RX filter
-         * rules as we are in NO_LINK mode. As the card is still
-         * logically linked, but it is doing a syncro site survey
-         * then it will be back to LINKED state.
-         */
-        IEEE80211_LINKED_SCANNING,
-
-};
 
 #define BEACON_PRIORITY 3
 #define LOW_PRIORITY 1
diff -U 3 -Nar o/rtl818x-newstack/r8180_core.c n/rtl818x-newstack/r8180_core.c
--- o/rtl818x-newstack/r8180_core.c	2008-02-16 13:47:49.000000000 +0300
+++ n/rtl818x-newstack/r8180_core.c	2008-02-17 01:30:29.000000000 +0300
@@ -529,13 +529,21 @@
 void rtl8180_proc_module_init(void)
 {	
 	DMESG("Initializing proc filesystem");
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,24))	
 	rtl8180_proc=create_proc_entry(RTL8180_MODULE_NAME, S_IFDIR, proc_net);
+#else
+	rtl8180_proc=create_proc_entry(RTL8180_MODULE_NAME, S_IFDIR, init_net.proc_net); 
+#endif
 }
 
 
 void rtl8180_proc_module_remove(void)
 {
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,24)) 
 	remove_proc_entry(RTL8180_MODULE_NAME, proc_net);
+#else
+	remove_proc_entry(RTL8180_MODULE_NAME, init_net.proc_net); 
+#endif
 }
 
 
@@ -3265,7 +3273,11 @@
 		else 
 			DMESG ("104-bit WEP is NOT supported in hardware");
 	}
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,24))	
 	if(request_irq(dev->irq, rtl8180_interrupt, SA_SHIRQ, dev->name, dev)){
+#else
+	if(request_irq(dev->irq, rtl8180_interrupt, IRQF_SHARED, dev->name, dev)){
+#endif
 		DMESGE("Error allocating IRQ %d",dev->irq);
 		return -1;
 	}else{ 
@@ -3949,9 +3961,10 @@
 		return -ENOMEM;
 	priv = ieee80211_priv(dev);
 	priv->ieee80211 = netdev_priv(dev);
-	
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,24))	
 	SET_MODULE_OWNER(dev);
-	
+#endif	
 	pci_set_drvdata(pdev, dev);
 	SET_NETDEV_DEV(dev, &pdev->dev);
 	
